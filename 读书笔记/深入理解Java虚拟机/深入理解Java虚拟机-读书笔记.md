# 深入理解 Java 虚拟机-读书笔记

## 第零部分 相关资源


## 第一部分 走进 Java



### 第1章 走进 Java

> Java 是一门编程语言，更是一个由一系列计算机软件和规范组成的技术体系



Java 的优点：

+ Java 虚拟机的存在，摆脱硬件平台的束缚，实现了“一次编写，到处运行”的理想
+ 提供了相对安全的内存管理和内存访问的机制，避免绝大部分的内存泄露和指针越界的问题
+ 实现了热点代码检测和运行时编译及优化，使得 Java 应用能随着运行时间的增长而获得更高的性能
+ 有一套完善的应用程序接口和无数来自商业机构和开源社区的第三方类库，提供了完善的功能



待完成。。。



## 第二部分 自动内存管理



### 第2章 Java 内存区域与内存溢出异常

> 本章从概念上介绍 Java 虚拟机内存的各个区域，讲解这些区域的作用、服务对象以及其中可能产生的问题，这也是翻越虚拟机内存管理围墙的第一步



#### 2.1 Java 虚拟机内存的区域划分

> 《Java 虚拟机规范》规定，Java 虚拟机所管理的内存包括几个运行时数据区域：方法区、堆、虚拟机栈、本地方法栈和程序计数器。

![Java 虚拟机运行时数据区](E:\my_projects\Learning-JVM\读书笔记\深入理解Java虚拟机\imgs\Java 虚拟机运行时数据区.png)



#### 2.2 程序计数器

> 程序计数器（Program Counter Register）可以看作是当前线程所执行的字节码的行号指示器，只占较小的内存空间。

在 Java 虚拟机的概念模型中，字节码解释器工作时就是通过改变程序计数器的值来选取下一条需要执行的字节码指令，因此程序计数器是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能均需要依赖程序计数器来完成。

##### 2.2.1 作用和服务对象

由于Java虚拟机的多线程是通过线程轮流切换、分配CPU执行时间的方式来实现（任意时刻，一个处理器只会执行一个线程中的指令），为了在线程切换后能恢复到正确的执行位置，每条线程都有一个独立的程序计数器。

如果线程正在的执行的是一个Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；

如果线程正在的执行的是一个本地方法，计数器的值为空（Undefined）。

##### 2.2.2 可能产生的问题

程序计数器内存区域是唯一一个在《Java 虚拟机规范》中没有规定任何 OutOfMemoryError 情况的区域。



#### 2.3 Java 虚拟机栈

##### 2.3.1 作用

Java 虚拟机栈描述的是 Java 方法执行的线程内存模型：每个 Java 方法被执行时，Java 虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法从被调用到执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

##### 2.3.2 服务对象

虚拟机栈为虚拟机执行 Java 方法服务

##### 2.3.3 可能产生的问题

如果线程请求的栈深度大于虚拟机允许的深度，将抛出 StackOverflowError 异常；

如果 Java 虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存，将抛出 OutOfMemoryError 异常。



#### 2.4 本地方法栈

##### 2.4.1 作用

作用与 Java 虚拟机栈类似

##### 2.4.2 服务对象

本地方法栈为虚拟机执行本地（Native）方法服务

##### 2.4.3 可能产生的问题

栈深度溢出：StackOverflowError

栈扩展失败：OutOfMemoryError



#### 2.5 Java 堆

##### 2.5.1 作用

《Java 虚拟机规范》描述：所有的对象实例以及数组都应当在堆上分配。

实际上，Java 中“几乎”所有的对象实例都在堆上分配。

##### 2.5.2 服务对象

Java 堆是垃圾收集器管理的内存区域。从回收内存的角度看，现代垃圾收集器大部分都是基于分代收集理论设计的；从分配内存的角度看，为提高对象分配效率，Java 堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer, TLAB）。

##### 2.5.3 可能产生的问题

当 Java 堆没有内存完成实例分配，且无法再扩展时，抛出 OutOfMemoryError 异常。



#### 2.6 方法区

##### 2.6.1 作用

用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

##### 2.6.2 服务对象



##### 2.6.3 可能产生的问题

如果方法区无法满足新的内存分配需求时，抛出 OutOfMemoryError 异常



#### 2.7 特殊概念

##### 2.7.1 运行时常量池

> 运行时常量池是方法区的一部分

用于存放编译期生成的各种字面量和符号引用的Class文件常量池表会在类加载后存放到方法区的运行时常量池，此外，运行期间也可以将新的常量（如 String 类的 intern() 方法）放入运行时常量池中。

##### 2.7.2 直接内存

直接内存不是虚拟机运行时数据区的一部分。直接内存不会受到 Java 堆大小的限制，但会受到本机总内存大小以及处理器寻址空间的限制。

#### 2.8 HotSpot 虚拟机对象揭秘

> 该部分所指的虚拟机都是 HotSpot 虚拟机。

##### 2.8.1 对象的创建

当 Java 虚拟机遇到一条字节码 new 指令时，首先检查该指令的参数是否能在常量池中定位到一个类的符号引用，并检查该符号引用代表的类是否已完成类加载过程（加载、连接【验证、准备、解析】、初始化），如果没有，必须先执行相应的类加载过程。

类加载检查通过之后，Java 虚拟机将为新生对象分配内存（对象所需内存大小在类加载完成后便可完全确定下来）。为对象分配内存空间等同于把一块确定大小的内存块从 Java 堆的可用空间中划分出来。按照 Java 堆内存是否绝对规整，对象的内存分配方式有两种：指针碰撞、空闲列表。而 Java 堆内存是否规则取决与所采用的垃圾收集器是否带有空间压缩整理的能力。为对象分配内存也存在并发时的线程安全问题，解决该问题有两种可选方案：一种是对分配内存空间的动作进行同步处理（采用CAS并失败重试机制）；另一种是把内存分配的动作按照线程划分在不同的空间中进行（本地线程分配缓存，TLAB，Thread Local Allocation Buffer），当本地缓存区用完之后，需要分配新的缓存区，此时需要同步锁定。

内存分配完成之后，虚拟机必须将分配的内存空间（不包括对象头）都初始化为零值，保证对象的实例字段有默认初始值。

之后，还需要对对象进行必要的设置（主要是设置对象头中的一些信息）。

最后执行构造方法。

##### 2.8.2 对象的内存布局

HotSpot 虚拟机中，对象在堆内存中的存储布局可划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

##### 2.8.3 对象的访问定位

### 第3章 垃圾收集器与内存分配策略



### 第4章 虚拟机性能监控、故障处理工具



### 第5章 调优案例分析与实战



## 第三部分 虚拟机执行子系统



### 第6章 类文件结构



### 第7章 虚拟机类加载机制



### 第8章 虚拟机字节码执行引擎



### 第9章 类加载及执行子系统的案例与实战



## 第四部分 程序编译与代码优化



### 第10章 前端编译与优化



### 第11章 后端编译与优化



## 第五部分 高效并发



### 第12章 Java 内存模型与线程



### 第13章 线程安全与锁优化

